# Error: 

The LINQ expression 'tr => tr.LanguageCode == __language_0' could not be translated. Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable', 'AsAsyncEnumerable', 'ToList', or 'ToListAsync'. See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.


# issue :

EF Core can't translate filtering on nested collections with .Where(...).ToList() directly inside the projection — especially when you're projecting into full entity objects.

Projection means : specify fields to return using select 

in simple words Ef cant translate where inside select to sql 

Translations = tr.Translations.Where(tr => tr.LanguageCode == language).ToList() 

EF Core can’t convert this into SQL if:
```csharp
Tags = p.Tags.Select(t => new Tag
{
    Id = t.Id,
    Code = t.Code,
    Translations = t.Translations.Where(tr => tr.LanguageCode == language).ToList()
}).ToList(),

```
# Solution : 

- Option 1 (BEST): Use DTOs for projection
  Avoid projecting full entity objects like Product, Category, AttributeValue, etc.
  Instead, create lightweight DTOs and do filtering easily.

  Would you like me to rewrite your whole method with DTOs? (Recommended for APIs)

- Option 2: Use .AsEnumerable() to switch to in-memory LINQ
  If you want a quick fix without changing everything to DTOs:

 Add .AsEnumerable() before .Select(...):
```csharp
return await _context.Products
    .Where(p => p.Id == productId)
    .AsEnumerable() // <-- switch to in-memory processing
    .Select(p => new Product
    {
        Id = p.Id,
        Price = p.Price,
        SalePrice = p.SalePrice,
        Translations = p.Translations
            .Where(tr => tr.LanguageCode == language).ToList(),

        Categories = p.Categories.Select(c => new Category
        {
            Id = c.Id,
            Slug = c.Slug,
            Translations = c.Translations
                .Where(tr => tr.LanguageCode == language).ToList()
        }).ToList()
    }).FirstOrDefaultAsync(); // now works

```
## EF Core will only fetch the Product with all navigation properties first,
## Then filter Translations in memory, not SQL.

⚠️ Warning:
   This loads all translations into memory — not great if you have thousands of them.

Best for small, well-scoped queries (like GetByIdAsync).

- Option 3: Load normally + filter manually later

```csharp
var product = await _context.Products
    .Include(p => p.Translations)
    .Include(p => p.Categories).ThenInclude(c => c.Translations)
    .Include(p => p.Tags).ThenInclude(t => t.Translations)
    .Include(p => p.ProductVariants)
        .ThenInclude(pv => pv.VariantAttributeValues)
            .ThenInclude(vav => vav.Attribute)
                .ThenInclude(a => a.Translations)
    .Include(p => p.ProductVariants)
        .ThenInclude(pv => pv.VariantAttributeValues)
            .ThenInclude(vav => vav.AttributeValue)
                .ThenInclude(av => av.Translations)
    .FirstOrDefaultAsync(p => p.Id == productId);

// THEN manually filter translations in memory
product.Translations = product.Translations
    .Where(tr => tr.LanguageCode == language).ToList();

foreach (var category in product.Categories)
    category.Translations = category.Translations
        .Where(tr => tr.LanguageCode == language).ToList();
```

Best for precise control
Verbose and not elegant if repeated too much.
